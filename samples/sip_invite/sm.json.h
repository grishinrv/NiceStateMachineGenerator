// generated by NiceStateMachineGenerator v1.0.0.0

#pragma once

#include <stdexcept>
#include <functional>


namespace generated
{
    
    template<class T>
    concept Timer = requires(T t) {
        { t.StartOrReset() };
        { t.Stop() };
    };
    
    template<Timer T>
    using TimerFiredCallback = void(*)(const T* timer);
    
    template<Timer T>
    using TimerFactory = T*(*)(const char* timerName, double timerDelaySeconds, TimerFiredCallback<T> callback);
    
    
    template <Timer T>
    class StateMachine
    {
    public:
        enum class States
        {
            Calling_Start,
            Calling_Retransmit,
            Proceeding,
            Completed,
            Terminated,
        };
        
        /*INVITE sent*/
        std::function<void()> OnStateEnter__Calling_Start;
        /*INVITE sent*/
        std::function<void()> OnStateEnter__Calling_Retransmit;
        /*The client transaction MUST be destroyed the instant it enters the 'Terminated' state*/
        std::function<void()> OnStateEnter__Terminated;
        
        /*Furthermore, the provisional response MUST be passed to the TU*/
        std::function<void(t_packet)> OnEventTraverse__SIP_1xx; 
        /*and the response MUST be passed up to the TU*/
        std::function<void(t_packet)> OnEventTraverse__SIP_2xx; 
        /*The client transaction MUST pass the received response up to the TU, and the client transaction MUST generate an ACK request*/
        std::function<void(t_packet)> OnEventTraverse__SIP_300_699; 
        /*Inform TU*/
        std::function<void()> OnEventTraverse__TransportError;
        /*the client transaction SHOULD inform the TU that a timeout has occurred.*/
        std::function<void()> OnTimerTraverse__Timer_B;
        /*Any retransmissions of the final response that are received while in the 'Completed' state MUST cause the ACK to be re-passed to the transport layer for retransmission, but the newly received response MUST NOT be passed up to the TU.*/
        std::function<void(t_packet)> OnEventTraverse__Completed__SIP_300_699; 
        
    private:
        States m_currentState = States::Calling_Start;
        T* Timer_A;
        T* Timer_A2;
        T* Timer_B;
        T* Timer_D;
        
    public:
        StateMachine(TimerFactory<T> timerFactory)
        {
            TimerFiredCallback<T> timerCallback = std::bind(&StateMachine::OnTimer, this, std::placeholders::_1);
            Timer_A = timerFactory("Timer_A", 0.5, timerCallback);
            Timer_A->Stop();
            Timer_A2 = timerFactory("Timer_A2", 2, timerCallback);
            Timer_A2->Stop();
            Timer_B = timerFactory("Timer_B", 32, timerCallback);
            Timer_B->Stop();
            Timer_D = timerFactory("Timer_D", 32, timerCallback);
            Timer_D->Stop();
        }
        
        ~StateMachine()
        {
            delete Timer_A;
            delete Timer_A2;
            delete Timer_B;
            delete Timer_D;
        }
        
        States GetCurrentState()
        {
            return m_currentState;
        }
        
        void Start()
        {
            m_currentState = States::Calling_Start;
            Timer_A->StartOrReset();
            Timer_B->StartOrReset();
            if (OnStateEnter__Calling_Start) { OnStateEnter__Calling_Start(); }
        }
        
        void ProcessEvent__SIP_1xx(t_packet packet)
        {
            switch (m_currentState)
            {
            case States::Calling_Start:
                if (OnEventTraverse__SIP_1xx) { OnEventTraverse__SIP_1xx(packet); }
                SetState(States::Proceeding);
                break;
                
            case States::Calling_Retransmit:
                if (OnEventTraverse__SIP_1xx) { OnEventTraverse__SIP_1xx(packet); }
                SetState(States::Proceeding);
                break;
                
            case States::Proceeding:
                if (OnEventTraverse__SIP_1xx) { OnEventTraverse__SIP_1xx(packet); }
                SetState(States::Proceeding);
                break;
                
            case States::Completed:
                break;
                
            default:
                throw std::runtime_error("Event SIP_1xx is not expected in current state " /* + this.CurrentState*/);
            }
        }
        
        void ProcessEvent__SIP_2xx(t_packet packet)
        {
            switch (m_currentState)
            {
            case States::Calling_Start:
                if (OnEventTraverse__SIP_2xx) { OnEventTraverse__SIP_2xx(packet); }
                SetState(States::Terminated);
                break;
                
            case States::Calling_Retransmit:
                if (OnEventTraverse__SIP_2xx) { OnEventTraverse__SIP_2xx(packet); }
                SetState(States::Terminated);
                break;
                
            case States::Proceeding:
                if (OnEventTraverse__SIP_2xx) { OnEventTraverse__SIP_2xx(packet); }
                SetState(States::Terminated);
                break;
                
            case States::Completed:
                break;
                
            default:
                throw std::runtime_error("Event SIP_2xx is not expected in current state " /* + this.CurrentState*/);
            }
        }
        
        void ProcessEvent__SIP_300_699(t_packet packet)
        {
            switch (m_currentState)
            {
            case States::Calling_Start:
                if (OnEventTraverse__SIP_300_699) { OnEventTraverse__SIP_300_699(packet); }
                SetState(States::Completed);
                break;
                
            case States::Calling_Retransmit:
                if (OnEventTraverse__SIP_300_699) { OnEventTraverse__SIP_300_699(packet); }
                SetState(States::Completed);
                break;
                
            case States::Proceeding:
                if (OnEventTraverse__SIP_300_699) { OnEventTraverse__SIP_300_699(packet); }
                SetState(States::Completed);
                break;
                
            case States::Completed:
                if (OnEventTraverse__Completed__SIP_300_699) { OnEventTraverse__Completed__SIP_300_699(packet); }
                SetState(States::Completed);
                break;
                
            default:
                throw std::runtime_error("Event SIP_300_699 is not expected in current state " /* + this.CurrentState*/);
            }
        }
        
        void ProcessEvent__TransportError()
        {
            switch (m_currentState)
            {
            case States::Calling_Start:
                if (OnEventTraverse__TransportError) { OnEventTraverse__TransportError(); }
                SetState(States::Terminated);
                break;
                
            case States::Calling_Retransmit:
                if (OnEventTraverse__TransportError) { OnEventTraverse__TransportError(); }
                SetState(States::Terminated);
                break;
                
            case States::Proceeding:
                if (OnEventTraverse__TransportError) { OnEventTraverse__TransportError(); }
                SetState(States::Terminated);
                break;
                
            case States::Completed:
                if (OnEventTraverse__TransportError) { OnEventTraverse__TransportError(); }
                SetState(States::Terminated);
                break;
                
            default:
                throw std::runtime_error("Event TransportError is not expected in current state " /* + this.CurrentState*/);
            }
        }
        
    private:
        void OnTimer(T* timer)
        {
            switch (m_currentState)
            {
            case States::Calling_Start:
                if (timer == Timer_A)
                {
                    SetState(States::Calling_Retransmit);
                }
                else if (timer == Timer_B)
                {
                }
                else 
                {
                    throw std::runtime_error("Unexpected timer finish in state Calling_Start");
                }
                break;
                
            case States::Calling_Retransmit:
                if (timer == Timer_A2)
                {
                    SetState(States::Calling_Retransmit);
                }
                else if (timer == Timer_B)
                {
                    if (OnTimerTraverse__Timer_B) { OnTimerTraverse__Timer_B(); }
                    SetState(States::Terminated);
                }
                else 
                {
                    throw std::runtime_error("Unexpected timer finish in state Calling_Retransmit");
                }
                break;
                
            case States::Completed:
                if (timer == Timer_D)
                {
                    SetState(States::Terminated);
                }
                else 
                {
                    throw std::runtime_error("Unexpected timer finish in state Completed");
                }
                break;
                
            default:
                throw std::runtime_error("No timer events expected in current state" /*+ this.CurrentState*/);
            }
        }
        
        void SetState(States state)
        {
            switch (state)
            {
            case States::Calling_Start:
                m_currentState = States::Calling_Start;
                Timer_A->StartOrReset();
                Timer_B->StartOrReset();
                if (OnStateEnter__Calling_Start) { OnStateEnter__Calling_Start(); }
                break;
                
            case States::Calling_Retransmit:
                m_currentState = States::Calling_Retransmit;
                Timer_A->Stop();
                Timer_A2->StartOrReset();
                if (OnStateEnter__Calling_Retransmit) { OnStateEnter__Calling_Retransmit(); }
                break;
                
            case States::Proceeding:
                m_currentState = States::Proceeding;
                Timer_A->Stop();
                Timer_A2->Stop();
                Timer_B->Stop();
                break;
                
            case States::Completed:
                m_currentState = States::Completed;
                Timer_A->Stop();
                Timer_A2->Stop();
                Timer_B->Stop();
                Timer_D->StartOrReset();
                break;
                
            case States::Terminated:
                m_currentState = States::Terminated;
                if (OnStateEnter__Terminated) { OnStateEnter__Terminated(); }
                break;
                
            default:
                throw std::runtime_error("Unexpected state " /* + state*/);
            }
        }
        
    };
}
