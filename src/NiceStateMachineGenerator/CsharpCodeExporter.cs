using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

namespace NiceStateMachineGenerator
{
    public sealed class CsharpCodeExporter
    {
        public sealed class Settings
        {
            public string NamespaceName { get; set; } = "Generated";
            public string ClassName { get; set; } = "StateMachine";
        }

        public static void Export(StateMachineDescr stateMachine, string fileName, Settings settings)
        {
            using (StreamWriter writer = new StreamWriter(fileName))
            {
                Export(stateMachine, writer, settings);
            }
        }

        public static void Export(StateMachineDescr stateMachine, TextWriter writer, Settings settings)
        {
            using (IndentedTextWriter indentedWriter = new IndentedTextWriter(writer))
            {
                Export(stateMachine, indentedWriter, settings);
            }
        }

        public static void Export(StateMachineDescr stateMachine, IndentedTextWriter writer, Settings settings)
        {
            CsharpCodeExporter exporter = new CsharpCodeExporter(stateMachine, writer, settings);
            exporter.ExportInternal();
        }

        private readonly StateMachineDescr m_stateMachine;
        private readonly IndentedTextWriter m_writer;
        private readonly Settings m_settings;

        private readonly Dictionary<StateDescr, string> m_stateToCallback = new Dictionary<StateDescr, string>();
        private readonly Dictionary<EdgeDescr, string> m_edgeToCallback = new Dictionary<EdgeDescr, string>();

        private CsharpCodeExporter(StateMachineDescr stateMachine, IndentedTextWriter writer, Settings settings)
        {
            this.m_stateMachine = stateMachine;
            this.m_writer = writer;
            this.m_settings = settings;
        }

        private void ExportInternal()
        {
            this.m_writer.WriteLine($"// generated by {nameof(NiceStateMachineGenerator)} v{Assembly.GetExecutingAssembly().GetName().Version}");
            WriteVerbatimCode(HEADER_CODE);
            this.m_writer.WriteLine($"namespace {this.m_settings.NamespaceName}");
            this.m_writer.WriteLine("{");
            {
                ++this.m_writer.Indent;
                this.m_writer.WriteLine($"public partial class {this.m_settings.ClassName}: IDisposable");
                this.m_writer.WriteLine("{");
                {
                    ++this.m_writer.Indent;
                    WriteVerbatimCode(TIMER_CODE);
                    WriteEnum(STATES_ENUM_NAME, this.m_stateMachine.States.Keys);
                    WriteCallbackEvents();
                    WriteFieldsAndConstructorDestructor();
                    WriteStart();
                    WriteOnTimer();
                    foreach (EventDescr @event in this.m_stateMachine.Events.Values)
                    {
                        WriteProcessEvent(@event);
                    };
                    WriteSetState();
                    --this.m_writer.Indent;
                }
                this.m_writer.WriteLine("}");  //class
                --this.m_writer.Indent;
            };
            this.m_writer.WriteLine("}"); //namespace
        }

        private void WriteSetState()
        {
            this.m_writer.WriteLine($"private void SetState({STATES_ENUM_NAME} state)");
            this.m_writer.WriteLine("{");
            {
                ++this.m_writer.Indent;
                this.m_writer.WriteLine("CheckNotDisposed();");
                this.m_writer.WriteLine("switch (state)");
                this.m_writer.WriteLine("{");
                {
                    foreach (StateDescr state in this.m_stateMachine.States.Values)
                    {
                        this.m_writer.WriteLine($"case {STATES_ENUM_NAME}.{state.Name}:");
                        ++this.m_writer.Indent;
                        {
                            WriteStateEnterCode(state);
                            if (state.NextStateName != null)
                            {
                                this.m_writer.WriteLine($"SetState({STATES_ENUM_NAME}.{state.NextStateName});");
                            }
                            this.m_writer.WriteLine("break;");
                        }
                        this.m_writer.WriteLine();
                        --this.m_writer.Indent;
                    };

                    this.m_writer.WriteLine($"default:");
                    ++this.m_writer.Indent;
                    {
                        this.m_writer.WriteLine("throw new Exception(\"Unexpected state \" + state);");
                    }
                    --this.m_writer.Indent;
                }
                this.m_writer.WriteLine("}");
                --this.m_writer.Indent;
            }
            this.m_writer.WriteLine("}");
            this.m_writer.WriteLine();
        }

        private void WriteProcessEvent(EventDescr @event)
        {
            this.m_writer.Write($"public void ProcessEvent__{@event.Name}(");
            for (int i = 0; i < @event.Args.Count; ++i)
            {
                KeyValuePair<string, string> arg = @event.Args[i];
                if (i != 0)
                {
                    this.m_writer.Write(", ");
                }
                this.m_writer.Write($"{arg.Value} {arg.Key}");
            }
            this.m_writer.WriteLine(")");
            this.m_writer.WriteLine("{");
            {
                ++this.m_writer.Indent;
                this.m_writer.WriteLine("CheckNotDisposed();");
                this.m_writer.WriteLine("switch (this.CurrentState)");
                this.m_writer.WriteLine("{");
                {
                    foreach (StateDescr state in this.m_stateMachine.States.Values)
                    {
                        if (state.EventEdges != null && state.EventEdges.TryGetValue(@event.Name, out EdgeDescr? edge))
                        {
                            this.m_writer.WriteLine($"case {STATES_ENUM_NAME}.{state.Name}:");
                            ++this.m_writer.Indent;
                            {
                                WriteEdgeTraverse(edge, isEvent: true);
                                this.m_writer.WriteLine("break;");
                            }
                            this.m_writer.WriteLine();
                            --this.m_writer.Indent;
                        }
                    };

                    this.m_writer.WriteLine($"default:");
                    ++this.m_writer.Indent;
                    {
                        this.m_writer.WriteLine($"throw new Exception(\"Event {@event.Name} is not expected in state \" + this.CurrentState);");
                    }
                    --this.m_writer.Indent;
                }
                this.m_writer.WriteLine("}");
                --this.m_writer.Indent;
            }
            this.m_writer.WriteLine("}");
            this.m_writer.WriteLine();
        }

        private void WriteOnTimer()
        {
            this.m_writer.WriteLine($"private void OnTimer(ITimer timer)");
            this.m_writer.WriteLine("{");
            {
                ++this.m_writer.Indent;
                this.m_writer.WriteLine("CheckNotDisposed();");
                this.m_writer.WriteLine("switch (this.CurrentState)");
                this.m_writer.WriteLine("{");
                {
                    foreach (StateDescr state in this.m_stateMachine.States.Values)
                    {
                        if (state.TimerEdges != null)
                        {
                            this.m_writer.WriteLine($"case {STATES_ENUM_NAME}.{state.Name}:");
                            ++this.m_writer.Indent;
                            {
                                foreach (EdgeDescr edge in state.TimerEdges.Values)
                                {
                                    this.m_writer.WriteLine($"if (timer == this.{edge.InvokerName})");
                                    this.m_writer.WriteLine("{");
                                    {
                                        ++this.m_writer.Indent;
                                        WriteEdgeTraverse(edge, isEvent: false);
                                        --this.m_writer.Indent;
                                    }
                                    this.m_writer.WriteLine("}");
                                    this.m_writer.Write("else ");
                                }
                                this.m_writer.WriteLine();
                                this.m_writer.WriteLine("{");
                                {
                                    ++this.m_writer.Indent;
                                    this.m_writer.WriteLine($"throw new Exception(\"Unexpected timer finish in state {state.Name}. Timer was \" + timer);");
                                    --this.m_writer.Indent;
                                }
                                this.m_writer.WriteLine("}");
                                this.m_writer.WriteLine("break;");
                            }
                            this.m_writer.WriteLine();
                            --this.m_writer.Indent;
                        }
                    };

                    this.m_writer.WriteLine($"default:");
                    ++this.m_writer.Indent;
                    {
                        this.m_writer.WriteLine("throw new Exception(\"No timer events expected in state \" + this.CurrentState);");
                    }
                    --this.m_writer.Indent;
                }
                this.m_writer.WriteLine("}");
                --this.m_writer.Indent;
            }
            this.m_writer.WriteLine("}");
            this.m_writer.WriteLine();
        }

        private void WriteEdgeTraverse(EdgeDescr edge, bool isEvent)
        {
            if (edge.NeedOnTraverseEvent)
            {
                string callbackName = this.m_edgeToCallback[edge];
                this.m_writer.Write($"{callbackName}?.Invoke(");
                if (isEvent)
                {
                    EventDescr @event = this.m_stateMachine.Events[edge.InvokerName];
                    for (int i = 0; i < @event.Args.Count; ++i)
                    {
                        KeyValuePair<string, string> arg = @event.Args[i];
                        if (i != 0)
                        {
                            this.m_writer.Write(", ");
                        }
                        this.m_writer.Write(arg.Key);
                    }
                }
                this.m_writer.WriteLine(");");
            };
            if (edge.TargetState != null)
            {
                this.m_writer.WriteLine($"SetState({STATES_ENUM_NAME}.{edge.TargetState});");
            }
        }

        private void WriteStart()
        {
            this.m_writer.WriteLine($"public void Start()");
            this.m_writer.WriteLine("{");
            {
                ++this.m_writer.Indent;
                this.m_writer.WriteLine("CheckNotDisposed();");
                WriteStateEnterCode(this.m_stateMachine.States[this.m_stateMachine.StartState]);
                --this.m_writer.Indent;
            }
            this.m_writer.WriteLine("}");
            this.m_writer.WriteLine();
        }

        private void WriteStateEnterCode(StateDescr state)
        {
            this.m_writer.WriteLine($"this.CurrentState = {STATES_ENUM_NAME}.{state.Name};");

            foreach (string timer in state.StopTimers)
            {
                this.m_writer.WriteLine($"this.{timer}.Stop();");
            }
            foreach (string timer in state.StartTimers)
            {
                this.m_writer.WriteLine($"this.{timer}.StartOrReset();");
            }

            if (state.NeedOnEnterEvent)
            {
                string callbackName = this.m_stateToCallback[state];
                this.m_writer.WriteLine($"{callbackName}?.Invoke();");
            }
        }

        private void WriteFieldsAndConstructorDestructor()
        {
            this.m_writer.WriteLine($"private bool m_isDisposed = false;");

            foreach (string timer in this.m_stateMachine.Timers.Keys)
            {
                this.m_writer.WriteLine($"private readonly ITimer {timer};");
            }

            this.m_writer.WriteLine();
            this.m_writer.WriteLine($"public {STATES_ENUM_NAME} CurrentState {{ get; private set; }} = {STATES_ENUM_NAME}.{this.m_stateMachine.StartState};");
            this.m_writer.WriteLine();
            this.m_writer.WriteLine($"public {this.m_settings.ClassName}(ITimerFactory timerFactory)");
            this.m_writer.WriteLine("{");
            {
                ++this.m_writer.Indent;
                foreach (TimerDescr timer in this.m_stateMachine.Timers.Values)
                {
                    this.m_writer.WriteLine($"this.{timer.Name} = timerFactory.CreateTimer(\"{timer.Name}\", {timer.IntervalSeconds.ToString(CultureInfo.InvariantCulture)}, this.OnTimer);");
                    this.m_writer.WriteLine($"this.{timer.Name}.Stop();");
                }
                --this.m_writer.Indent;
            }
            this.m_writer.WriteLine("}");
            this.m_writer.WriteLine();

            this.m_writer.WriteLine($"public void Dispose()");
            this.m_writer.WriteLine("{");
            {
                ++this.m_writer.Indent;
                this.m_writer.WriteLine("if (!this.m_isDisposed)");
                this.m_writer.WriteLine("{");
                {
                    ++this.m_writer.Indent;
                    foreach (string timer in this.m_stateMachine.Timers.Keys)
                    {
                        this.m_writer.WriteLine($"this.{timer}.Dispose();");
                    }
                    this.m_writer.WriteLine($"this.m_isDisposed = true;");
                    --this.m_writer.Indent;
                }
                this.m_writer.WriteLine("}");
                --this.m_writer.Indent;
            }
            this.m_writer.WriteLine("}");
            this.m_writer.WriteLine();

            this.m_writer.WriteLine($"private void CheckNotDisposed()");
            this.m_writer.WriteLine("{");
            {
                ++this.m_writer.Indent;
                this.m_writer.WriteLine("if (this.m_isDisposed)");
                this.m_writer.WriteLine("{");
                {
                    ++this.m_writer.Indent;
                    this.m_writer.WriteLine($"throw new ObjectDisposedException(\"{this.m_settings.ClassName}\");");
                    --this.m_writer.Indent;
                }
                this.m_writer.WriteLine("}");
                --this.m_writer.Indent;
            }
            this.m_writer.WriteLine("}");
            this.m_writer.WriteLine();
        }

        private void WriteEnum(string enumName, IEnumerable<string> values)
        {
            this.m_writer.WriteLine($"public enum {enumName}");
            this.m_writer.WriteLine("{");
            {
                ++this.m_writer.Indent;
                foreach (string @event in values)
                {
                    this.m_writer.Write(@event);
                    this.m_writer.WriteLine(",");
                };
                --this.m_writer.Indent;
            }
            this.m_writer.WriteLine("}");
            this.m_writer.WriteLine("");
        }

        private void WriteCallbackEvents()
        {
            foreach (StateDescr state in this.m_stateMachine.States.Values)
            {
                if (state.NeedOnEnterEvent)
                {
                    string callbackName = $"OnStateEnter__{state.Name}";
                    this.m_stateToCallback.Add(state, callbackName);
                    this.m_writer.WriteLine($"public event Action {callbackName};");
                }
            }
            this.m_writer.WriteLine();

            foreach (StateDescr state in this.m_stateMachine.States.Values)
            {
                if (state.EventEdges != null)
                {
                    foreach (EdgeDescr edge in state.EventEdges.Values)
                    {
                        if (edge.NeedOnTraverseEvent)
                        {
                            string callbackName = $"OnEventTraverse__{state.Name}__{edge.InvokerName}__{edge.TargetState}";
                            this.m_edgeToCallback.Add(edge, callbackName);
                            EventDescr @event = this.m_stateMachine.Events[edge.InvokerName];
                            if (@event.Args.Count == 0)
                            {
                                this.m_writer.WriteLine($"public event Action {callbackName};");
                            }
                            else
                            {
                                this.m_writer.Write($"public event Action<");
                                for (int i = 0; i < @event.Args.Count; ++i)
                                {
                                    KeyValuePair<string, string> arg = @event.Args[i];
                                    if (i != 0)
                                    {
                                        this.m_writer.Write(", ");
                                    };
                                    this.m_writer.Write($"{arg.Value}");
                                }
                                this.m_writer.WriteLine($"> {callbackName}; ");
                            }
                        }
                    }
                }
                if (state.TimerEdges != null)
                {
                    foreach (EdgeDescr edge in state.TimerEdges.Values)
                    {
                        if (edge.NeedOnTraverseEvent)
                        {
                            string callbackName = $"OnTimerTraverse__{state.Name}__{edge.InvokerName}__{edge.TargetState}";
                            this.m_edgeToCallback.Add(edge, callbackName);
                            this.m_writer.WriteLine($"public event Action {callbackName};");
                        }
                    }
                }
            }
            this.m_writer.WriteLine();
        }

        private static Regex s_splitRegex = new Regex(@"\r?\n", RegexOptions.Compiled);
        private void WriteVerbatimCode(string code)
        {
            foreach (string line in s_splitRegex.Split(code))
            {
                this.m_writer.WriteLine(line);
            }
        }

        private const string STATES_ENUM_NAME = "States";

        private const string HEADER_CODE =
@"
using System;
";

        private const string TIMER_CODE =
@"
public delegate void TimerFiredCallback(ITimer timer);

public interface ITimer: IDisposable
{
    void StartOrReset();
    void Stop();
}

public interface ITimerFactory
{
    ITimer CreateTimer(string timerName, double timerDelaySeconds, TimerFiredCallback callback);
}

";

    }
}
